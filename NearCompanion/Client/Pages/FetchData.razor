@page "/"
@using NearCompanion.Client.Services.Interfaces
@using NearCompanion.Shared
@using NearCompanion.Client.Components
@using System.Net
@using System.Text
@using Newtonsoft.Json
@using System.Collections.ObjectModel
@inject HttpClient Http

<PageTitle>Weather forecast</PageTitle>

@if (blocks == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <div class="wrapper">
        <div class="container">
            <div class="row">
                <div class="col-sm-2">
                </div>

                <div class="col-sm-8 d-flex justify-content-center align-items-center">
                    <button @onclick="HandlePlayPause" 
                            id="stop-button" 
                            class="xd-button hoverableButton d-flex justify-content-center align-items-center">
                        @currentPlayPauseText
                    </button>
                </div>

                <div class="col-sm-2">
                </div>
            </div>
        </div>

        <div class="@GetClassName()">
            @foreach (var block in blocks)
            {
                <Block Model=block @key="block"/>
            }
        </div>
    </div>
}

@code 
{
    private List<BlockModel> blocks = new List<BlockModel>();

    private bool isInsertingNewBlock = false;
    string GetClassName() => isInsertingNewBlock ? "blocksContainer rightShift" : "blocksContainer";
    private bool isRunning = true;
    private const string STOP_TEXT = "⏸ Pause";
    private const string PLAY_TEXT = "▶ Resume";
    private string currentPlayPauseText = STOP_TEXT;

    protected override async Task OnInitializedAsync()
    {
        var firstBlock = await Http.GetFromJsonAsync<Response<BlockModel>>("block");
        ulong previousHeight = firstBlock.Data.Height;
        blocks.Add(firstBlock.Data);
        previousHeight++;
        AnnounceStateHasChanged();

        while (true)
        {
            var block = await Http.GetFromJsonAsync<Response<List<BlockModel>>>($"block/{previousHeight}");

            if (block.Data.Count != 0)
            {
                foreach (var newBlock in block.Data)
                {
                    _ = AddBlockAndHandleAnimations(newBlock, (int)newBlock.LengthMs);
                    await Task.Delay((int)newBlock.LengthMs);
                    previousHeight++;
                }
            }
            else
            {
                await Task.Delay(1000);
            }
        }

        Console.WriteLine("Exited loop");
    }

    private async Task AddBlockAndHandleAnimations(BlockModel block, int duration)
    {
        isInsertingNewBlock = true;
        AnnounceStateHasChanged();

        await Task.Delay(250);

        blocks.Add(block);
        AnnounceStateHasChanged();
        isInsertingNewBlock = false;
        AnnounceStateHasChanged();

        if (blocks.Count > 10)
        {
            blocks.RemoveAt(0);
            AnnounceStateHasChanged();
        }
    }

    private void HandlePlayPause()
    {
        isRunning = !isRunning;
        currentPlayPauseText = isRunning ? STOP_TEXT : PLAY_TEXT;
        StateHasChanged();
    }

    private void AnnounceStateHasChanged()
    {
        if (isRunning)
        {
            StateHasChanged();
        }
    }

}