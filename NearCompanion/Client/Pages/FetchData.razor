@page "/"
@using NearCompanion.Client.Services
@using NearCompanion.Client.Services.Interfaces
@using NearCompanion.Shared
@using NearCompanion.Client.Components
@using System.Net
@using System.Text
@using Newtonsoft.Json
@using System.Collections.ObjectModel
@using System.Collections.Specialized
@inject HttpClient Http
@inject IBlockService BlockService

<PageTitle>Weather forecast</PageTitle>

@if (blocks == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <div>
        <div class="container">
            <div class="row">
                <div class="col-sm-2">
                </div>

                <div class="col-sm-8 d-flex justify-content-center align-items-center">
                    <button @onclick="HandlePlayPause" 
                            id="stop-button" 
                            class="xd-button hoverableButton d-flex justify-content-center align-items-center">
                        @currentPlayPauseText
                    </button>
                </div>

                <div class="col-sm-2">
                </div>
            </div>
        </div>

        <div class="@GetClassName()">
            @foreach (var block in blocks)
            {
                <Block Model=block @key="block"/>
            }
        </div>
    </div>

    @*<ol type="1">
        @for (var i = 0; i <= number; i++)
        {
            <li>@word + " " + @i</li>
        }
    </ol>*@
}

@code 
{
    private int number = 4;
    private string word = "asdsa";
    private List<BlockModel> blocks = new List<BlockModel>();
    private ObservableCollection<BlockModel> blocksQueue = new ObservableCollection<BlockModel>();

    private bool isInsertingNewBlock = false;
    string GetClassName() => isInsertingNewBlock ? "blocksContainer rightShift" : "blocksContainer";
    private bool isRunning = true;
    private const string STOP_TEXT = "⏸ Pause";
    private const string PLAY_TEXT = "▶ Resume";
    private string currentPlayPauseText = STOP_TEXT;
    private bool dequeuingBlocks = false;

    protected override async Task OnInitializedAsync()
    {
        blocksQueue.CollectionChanged += OnBlockQueueChanged; 
        BlockService.NewBlocksReceivedEvent += OnNewBlocksReceived;
        await BlockService.StartReceivingBlocks();
    }

    private void OnBlockQueueChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        if (e.Action == NotifyCollectionChangedAction.Add && !dequeuingBlocks)
        {
            // start showing
            _ = DequeBlocks();
        }
    }

    private async Task DequeBlocks()
    {
        while (blocksQueue.Count > 0)
        {
            dequeuingBlocks = true;
            Console.WriteLine($"Currently {blocksQueue.Count} blocks are in queue");

            // Getting too behind
            if (blocksQueue.Count > 15)
            {
                blocks.AddRange(blocksQueue.Take(14));

                foreach (var block in blocksQueue.Take(14))
                {
                    blocksQueue.Remove(block);
                }

                AnnounceStateHasChanged();
                
                continue;
            }
            
            _ = AddBlockAndHandleAnimations(blocksQueue.First());
            await Task.Delay((int)blocksQueue.First().LengthMs);
            blocksQueue.RemoveAt(0);
        }

        dequeuingBlocks = false;
    }

    private void OnNewBlocksReceived(object? sender, NewBlocksReceivedEventArgs e)
    {
        lock (blocksQueue)
        {
            foreach (var newBlock in e.Blocks)
            {
                blocksQueue.Add(newBlock);
            }
        }
    }

    private async Task AddBlockAndHandleAnimations(BlockModel block)
    {
        isInsertingNewBlock = true;
        AnnounceStateHasChanged();

        await Task.Delay(250);

        blocks.Add(block);
        AnnounceStateHasChanged();
        isInsertingNewBlock = false;
        AnnounceStateHasChanged();

        if (blocks.Count > 10)
        {
            blocks.RemoveAt(0);
            AnnounceStateHasChanged();
        }
    }

    private void HandlePlayPause()
    {
        isRunning = !isRunning;
        currentPlayPauseText = isRunning ? STOP_TEXT : PLAY_TEXT;
        StateHasChanged();
    }

    private void AnnounceStateHasChanged()
    {
        if (isRunning)
        {
            StateHasChanged();
        }
    }

}